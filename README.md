# Implementations of Algorithms and Data Structures in C++

Author: [CodeJogot](https://www.youtube.com/@CodeJogot)

### 01. Number Theory

| **No** | **Name of Algorithm/Problem**              | **Written Explanation** | **Source Code** | **Video Explanation in Bangla** | **Video Explanation in English** |
| ------ | ------------------------------------------ | ----------------------- | --------------- | ------------------------------- | -------------------------------- |
| 1      | Bigmod                                     | [Read Now]()            | [View Code]()   | [Watch Now]()                   | [Watch Now]()                    |
| 2      | Bigmod (Bitwise)                           | [Read Now]()            | [View Code]()   | [Watch Now]()                   | [Watch Now]()                    |
| 3      | Prime Generation                           | [Read Now]()            | [View Code]()   | [Watch Now]()                   | [Watch Now]()                    |
| 4      | Sieve-1 (for prime check)                  | [Read Now]()            | [View Code]()   | [Watch Now]()                   | [Watch Now]()                    |
| 5      | Sieve-2 (for distinct prime factor)        | [Read Now]()            | [View Code]()   | [Watch Now]()                   | [Watch Now]()                    |
| 6      | Sieve-3 (for sum of distinct prime factor) | [Read Now]()            | [View Code]()   | [Watch Now]()                   | [Watch Now]()                    |
| 7      | Sieve-4 (for number of divisor-1)          | [Read Now]()            | [View Code]()   | [Watch Now]()                   | [Watch Now]()                    |
| 8      | Sieve-5 (for number of divisor-2)          | [Read Now]()            | [View Code]()   | [Watch Now]()                   | [Watch Now]()                    |
| 9      | Sieve-6 (for sum of divisor)               | [Read Now]()            | [View Code]()   | [Watch Now]()                   | [Watch Now]()                    |
| 10     | Extended Euclid                            | [Read Now]()            | [View Code]()   | [Watch Now]()                   | [Watch Now]()                    |
| 11     |                                            |                         |                 |                                 |                                  |
| 12     |                                            |                         |                 |                                 |                                  |
| 13     |                                            |                         |                 |                                 |                                  |
| 14     |                                            |                         |                 |                                 |                                  |
| 15     |                                            |                         |                 |                                 |                                  |

### 02. Graph Theory

| **No** | **Name of Algorithm/Problem**        | **Written Explanation** | **Source Code** | **Video Explanation in Bangla** | **Video Explanation in English** |
| ------ | ------------------------------------ | ----------------------- | --------------- | ------------------------------- | -------------------------------- |
| 1      | Depth-First Search(DFS)              | [Read Now]()            | [View Code]()   | [Watch Now]()                   | [Watch Now]()                    |
| 2      | Dijkstra                             | [Read Now]()            | [View Code]()   | [Watch Now]()                   | [Watch Now]()                    |
| 3      | Dijkstra With Printing Path          | [Read Now]()            | [View Code]()   | [Watch Now]()                   | [Watch Now]()                    |
| 4      | Minimum Spanning Tree(MST-Prims)     | [Read Now]()            | [View Code]()   | [Watch Now]()                   | [Watch Now]()                    |
| 5      | Minimum Spanning Tree(MST-Kruskal)   | [Read Now]()            | [View Code]()   | [Watch Now]()                   | [Watch Now]()                    |
| 6      | Topological Sort(In-degree Solution) | [Read Now]()            | [View Code]()   | [Watch Now]()                   | [Watch Now]()                    |
| 7      | Topological Sort(DFS Solution)       | [Read Now]()            | [View Code]()   | [Watch Now]()                   | [Watch Now]()                    |
| 8      | Strongly Connected Components(SCC)   | [Read Now]()            | [View Code]()   | [Watch Now]()                   | [Watch Now]()                    |
| 9      | Articulation Point                   | [Read Now]()            | [View Code]()   | [Watch Now]()                   | [Watch Now]()                    |
| 10     | Articulation Bridge                  | [Read Now]()            | [View Code]()   | [Watch Now]()                   | [Watch Now]()                    |
| 11     | Lowest Common Ancestor               | [Read Now]()            | [View Code]()   | [Watch Now]()                   | [Watch Now]()                    |
| 12     |                                      |                         |                 |                                 |                                  |
| 13     |                                      |                         |                 |                                 |                                  |
| 14     |                                      |                         |                 |                                 |                                  |
| 15     |                                      |                         |                 |                                 |                                  |

### 03. Data Structures

| **No** | **Name of Algorithm/Problem**      | **Written Explanation**                                        | **Source Code**                            | **Video Explanation in Bangla** | **Video Explanation in English** |
| ------ | ---------------------------------- | -------------------------------------------------------------- | ------------------------------------------ | ------------------------------- | -------------------------------- |
| 1      | [Binary Search](#01-binary-search) | [Read Now](#written-explanation-step-by-step-of-binary-search) | [View Code](#source-code-of-binary-search) | [Watch Now]()                   | [Watch Now]()                    |
| 2      | Trie-01                            | [Read Now]()                                                   | [View Code]()                              | [Watch Now]()                   | [Watch Now]()                    |
| 3      | Trie-02                            | [Read Now]()                                                   | [View Code]()                              | [Watch Now]()                   | [Watch Now]()                    |
| 4      | Histogram With Stack               | [Read Now]()                                                   | [View Code]()                              | [Watch Now]()                   | [Watch Now]()                    |
| 5      | Segment Tree-1                     | [Read Now]()                                                   | [View Code]()                              | [Watch Now]()                   | [Watch Now]()                    |
| 6      | Segment Tree-2                     | [Read Now]()                                                   | [View Code]()                              | [Watch Now]()                   | [Watch Now]()                    |
| 7      | Segment Tree-3                     | [Read Now]()                                                   | [View Code]()                              | [Watch Now]()                   | [Watch Now]()                    |
| 8      | Segment Tree-4 (with Lazy)         | [Read Now]()                                                   | [View Code]()                              | [Watch Now]()                   | [Watch Now]()                    |
| 9      | Segment Tree-5 (with Lazy)         | [Read Now]()                                                   | [View Code]()                              | [Watch Now]()                   | [Watch Now]()                    |
| 10     | Segment Tree-6 (with Lazy)         | [Read Now]()                                                   | [View Code]()                              | [Watch Now]()                   | [Watch Now]()                    |
| 11     |                                    |                                                                |                                            |                                 |                                  |
| 12     |                                    |                                                                |                                            |                                 |                                  |
| 13     |                                    |                                                                |                                            |                                 |                                  |
| 14     |                                    |                                                                |                                            |                                 |                                  |
| 15     |                                    |                                                                |                                            |                                 |                                  |

# 01. Binary Search

### Difficulty: Easy(3/10)

### You Will Learn

- কিভাবে Binary Search Algorithm কাজ করে।
- একটা Sorted Array তে কোন Element কিভাবে **_O(log(n))_** time complexity তে সার্চ করা যায়।

### Problem Description

- একটা Sorted Array দেয়া আছে। এই Array থেকে **_O(log(n))_** তে কোন Element Search করে দেখতে হবে Element টি আছে কিনা। যদি থাকে তাহলে _Found_ আর না থাকলে _Not Found_ আউটপুট আঁকারে দেখাবে।

### Written Explanation (Step by Step) of Binary Search

### Source Code of Binary Search

```cpp
/*
    Algorithm Used: Binary Search
    Complexity: O(log(N))
    Solution Approach:
*/

#include <bits/stdc++.h>
using namespace std;
#define LL long long
#define MAX 100009

int a[MAX];

bool binarySearch(int left, int right, int value)
{
    while (left <= right)
    {
        int mid = (left + right) / 2;
        if (a[mid] == value)
            return 1;
        else if (a[mid] < value)
            left = mid + 1;
        else
            right = mid - 1;
    }
    return 0;
}

int main()
{
    int i, j, k, n, m, d, value;
    while (cin >> n)
    {
        for (i = 0; i < n; i++)
            cin >> a[i];
        sort(a, a + n);
        cin >> value;
        if (binarySearch(0, n - 1, value))
            cout << "Found" << endl;
        else
            cout << "Not Found" << endl;
    }
    return 0;
}
```

### Video Explanation in Bangla

### Video Explanation in English

<div align="right">
    <b><a href="#1-number-theory">↥ Go to Number Theory</a></b>
</div>
